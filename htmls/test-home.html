<!doctype html>
<html>

<head>
	<title>Contents</title>
	<link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css' rel='stylesheet' />
	<link href='https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css' rel='stylesheet' />

	<script src='https://code.jquery.com/jquery-3.5.1.slim.min.js'></script>
	<script src='https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.3/dist/umd/popper.min.js'></script>
	<script src='https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js'></script>

	<script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>

	<script type="text/javascript">

		/**
		 * The list of categories are loaded by another JavaScript and embeded in Cross-Column section.
		 * animal, people, plant, thing, etc. The data is stored in a global variable allWords.
		 */

		// Google's text-to-speech and speech-to-text services URLs
		const TTS_URL = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${API_KEY}`;
		const STT_URL = `https://speech.googleapis.com/v1/speech:recognize?key=${API_KEY}`;

		// The URL of the default image
		const DEFAULT_IMG = 'https://lh3.googleusercontent.com/pw/AP1GczMucMzJdrDwjYiwm8pd_8sP_40vE3uZH0OJgYGOpA6CBNKMRXlDBtoXKm72CwdG4B3AXGG8KMQmhf-sp5dVcR3Ld6ysg1FAM9d2IiGHU7PCJQrPW9-6JfaQ-eeh3gviLEYS__MsPB5bntFnmMF4Q_B7EA=w1024-h1024-s-no-gm?authuser=0';

		// Turn on/off the animation while drawing a character
		let animation = true;

		/**
		 * Updates the page when all the words are ready to use
		 */
		function updatePage(id) {
			const intervalId = setInterval(() => {
				if (allWords.length > 0) {
					clearInterval(intervalId);
					clearSpeechSection();
					let word = findWord(id);
					if (word == null) {
						let sentence = document.getElementById('sentence');
						sentence.textContent = "Refresh the page";
						return;
					}
					buildWordEntry(word);
					draw(word);
				}
			}, 100);
		}

		/**
		 * Builds the HTML elements of the word entry
		 */
		function buildWordEntry(word) {
			let english = document.getElementById('english');
			let chinese = document.getElementById('chinese');
			english.textContent = word.english.trim();
			chinese.textContent = word.chinese.trim();
			buildPicture(word);
			buildWordCard('word-card', word);
		}

		/**
		 * Builds the picture element.
		 */
		function buildPicture(word) {
			let defaultPicture = document.getElementById('picture-default');
			defaultPicture.src = DEFAULT_IMG;
			defaultPicture.style.display = 'block';

			let picture = document.getElementById('picture');
			let char = word.chinese;
			let today = new Date();
			let texts = [];
			let image = word.image;
			if (image.length == 0) {
				switch (char) {
					case '‰ªä':
						texts.push('‰ªäÂ§©:');
						texts.push(today.getFullYear() + 'Âπ¥' + (today.getMonth() + 1) + 'Êúà' + today.getDate() + 'Âè∑');
						texts.push('------');
						texts.push('‰ªäÂπ¥:');
						texts.push(today.getFullYear() + 'Âπ¥ ');
						image = createBase64Image(texts);
						break;
					case 'Êò®':
						let yesterday = new Date(today);
						yesterday.setDate(today.getDate() - 1);
						texts.push('Êò®Â§©:')
						texts.push(today.getFullYear() + 'Âπ¥' + (yesterday.getMonth() + 1) + 'Êúà' + yesterday.getDate() + 'Âè∑');
						texts.push('------');
						texts.push('ÂéªÂπ¥:');
						texts.push((today.getFullYear() - 1) + 'Âπ¥');
						image = createBase64Image(texts);
						break;
					case 'Êòé':
						let tomorrow = new Date(today);
						tomorrow.setDate(today.getDate() + 1);
						texts.push('ÊòéÂ§©:');
						texts.push(tomorrow.getFullYear() + 'Âπ¥' + (tomorrow.getMonth() + 1) + 'Êúà' + tomorrow.getDate() + 'Âè∑');
						texts.push('------');
						texts.push('ÊòéÂπ¥:');
						texts.push((tomorrow.getFullYear() + 1) + 'Âπ¥');
						image = createBase64Image(texts);
						break;
					default:
						texts.push('Picture');
						texts.push('is coming');
						texts.push('soon ...');
						image = createBase64Image(texts);
				}
			}
			picture.src = image;
			picture.style.display = 'none';
		}

		/**
		 * Shows the picture. It needs to be async for the print function.
		 */
		async function showPicture() {
			return new Promise(resolve => {
				setTimeout(() => {
					let defaultPicture = document.getElementById('picture-default');
					let picture = document.getElementById('picture');
					let isDefault = defaultPicture.style.display == 'block';

					defaultPicture.style.display = (isDefault ? 'none' : 'block');
					picture.style.display = (isDefault ? 'block' : 'none');
					resolve();
				}, 100);
			});
		}

		function setAnimation(animation) {
			animation = animation;
		}

		function isAnimation() {
			return animation;
		}

		function createBase64Image(texts) {
			let canvas = document.getElementById("textCanvas");
			let ctx = canvas.getContext("2d");
			canvas.height = 300;
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			// Set text properties: volot, size, style, align, etc.
			ctx.fillStyle = "Brown";
			ctx.font = "40px SimSun";
			ctx.textAlign = "left";
			ctx.textBaseline = "baseline";

			// Draw text on the canvas
			let height = 48;
			for (let i = 0; i < texts.length; i++) {
				ctx.fillText(texts[i], 10, height);
				height += 45;
			}

			// Convert canvas content to Base64
			let base64Image = canvas.toDataURL("image/png"); // Image format: PNG
			return base64Image;
		}

		/**
		 * Draws a Chinese character in the standard strok order.
		 */
		async function draw(word) {
			return new Promise(resolve => {
				setTimeout(() => {
					let character = document.getElementById('character');
					let charSize = 32;
					character.textContent = '';
					character.value = word.chinese.trim();
					switch (character.value.length) {
						case 1:
							charSize = 250;
							break;
						case 2:
							charSize = 130;
							break;
						case 3:
							charSize = 85;
							break;
						default:
							charSize = 32;
					};

					let chars = Array.from(character.value);
					let writer;
					for (let i = 0; i < chars.length; i++) {
						writer = HanziWriter.create('character', chars[i], {
							width: charSize,
							height: charSize,
							padding: 5,
							strokeColor: '#006400',
							showOutline: true,
							strokeAnimationSpeed: 1, // normal speed
							delayBetweenStrokes: 200 // milliseconds
						});
						if (isAnimation() && chars.length == 1) {
							writer.animateCharacter();
						}
					}
					resolve();
				}, 300);
			});
		}

		/**
		 * Finds the Chinese character card (pinyin, phrase and sentence)
		 */
		function buildWordCard(cardId, word) {
			let wordElement = document.getElementById(cardId);
			let pinyin = wordElement.querySelector('#pinyin');
			let phrase = wordElement.querySelector('#phrase');
			let sentence = wordElement.querySelector('#sentence');
			pinyin.textContent = word.pinyin.trim();
			phrase.textContent = word.phrase[0].trim();
			sentence.textContent = word.sentence.trim();
		}

		/**
		 * Finds the Chinese character from the current category object
		 */
		function findWord(id) {
			if (allWords.length == 0) {
				return null;
			}

			let category = allWords.find(item => item.category == currentCategory);
			let word = category.words.find(item => item.chinese == id);
			if (word != null) {
				currentCategory = category.category;
				return word;
			}
			return allWords[0].words[0];
		}

		/**
		 * Builds a category list from the allWords object as a clickable category selector
		 */
		function buildCategories() {
			const intervalId = setInterval(() => {
				if (allWords.length > 0) {
					clearInterval(intervalId);
					let word = null;
					let category = null;
					console.log('Start building categories');

					// build HTML elements for the clickable categories
					let id, cname, row, col;
					let colIdx = 0;
					let numCol = 6;
					let div = document.getElementById('category-row');
					div.innerHTML = '';
					for (let i = 0; i < allWords.length; i += numCol) {
						row = document.createElement('div');
						row.className = 'row';
						for (let j = 0; (j < numCol && colIdx < (allWords.length - 1)); j++) {
							colIdx = i + j;
							category = allWords[colIdx];
							id = category.category;
							cname = category.cname;
							col = document.createElement('div');
							col.id = id;
							col.className = 'col-sm-2 clickable';
							col.textContent = cname + ' - ' + id;
							// col.textContent = id;
							col.onclick = function () { setCategory(this.id); };
							row.appendChild(col);
						}
						div.appendChild(row);
					}
				}
			}, 100);
		}

		/**
		 * Sets the current catagory, rebuild the word entry and side bar
		 */
		function setCategory(category) {
			currentCategory = category;
			let categoryObject = allWords.find(item => item.category == currentCategory);
			let id = categoryObject.words[0].chinese;
			updatePage(id);
			buildWordList();
		}

		/**
		 * Uses Google's text to speech service to say the specified text.
		 */
		async function say(lang, id) {
			let tag = document.getElementById(id);
			let text = tag.textContent;
			if (text.length == 0) {
				text = tag.value;
			}
			if (text.length > 0) {
				talk(lang, text);
			}
		}

		/**
		 * Uses Google's text to speech service to say the specified text.
		 * Chinese Mandarin, female cmn-CN-Standard-A
		 * Chinese Mandarin, female cmn-TW-Wavenet-A (better)
		 * Chinese Cantonese, female yue-HK-Standard-A
		 * English U.S., female en-US-Standard-E
		 */
		async function talk(lang, text) {
			let langCode, langName;

			if (lang == 'zh-CN') {
				langCode = 'cmn-CN';
				langName = 'cmn-TW-Wavenet-A'
			} else if (lang == 'yue-HK') {
				langCode = 'yue-HK';
				langName = 'yue-HK-Standard-A'
			} else {
				langCode = 'en-US';
				langName = 'en-US-Standard-E'
			}

			const requestBody = {
				input: {
					text: text
				},
				voice: {
					languageCode: langCode,
					name: langName
				},
				audioConfig: {
					audioEncoding: 'MP3',
					speakingRate: 0.9
				}
			};

			try {
				const response = await fetch(TTS_URL, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json'
					},
					body: JSON.stringify(requestBody)
				});

				if (!response.ok) {
					return response.statusText;
				}

				const data = await response.json();
				const audioContent = data.audioContent;

				// Create a Blob from the base64 audio content  
				const audioBlob = new Blob([Uint8Array.from(atob(audioContent), c => c.charCodeAt(0))], {
					type: 'audio/mp3'
				});
				const audioUrl = URL.createObjectURL(audioBlob);

				// Create a dynamic audio element  
				const audioElement = new Audio(audioUrl);
				audioElement.play().catch(error => {
					console.error('Error playing audio:', error);
				});

				// Remove the audio element after playback ends  
				audioElement.addEventListener('ended', () => {
					URL.revokeObjectURL(audioUrl); // Clean up the URL  
				});
			} catch (error) {
				// TODO error handling
				console.error(error);
			}
		}

		/**
		 * If some text is highlighted in phrase or sentence elements, say the highlighted text.
		 */
		function sayHighlighted() {
			let selection = window.getSelection();
			let selectedText = selection.toString(); // Get the text of the selection
			if (selectedText.length > 0 && selection.rangeCount > 0) {
				let range = selection.getRangeAt(0); // Get the selected range
				let parentElement = range.commonAncestorContainer; // Get the common parent of the selection

				// Check if the parent element is inside the target element
				let wordEntry = document.getElementById('word-entry');
				if (wordEntry.contains(parentElement)) {
					talk('zh-CN', selectedText);
				}
			}
		}

		/**
		 * Gets voice from a microphone, converts it to a text, gets pinyins of both
		 * input text and the selected text, and finally checks if they are same. This is
		 * used to practice pronunciation.
		 */
		async function speechCheck(lang, id) {
			clearSpeechSection();
			let talkTag = document.getElementById('speech-check');
			talkTag.style.display = 'block';
			let wordTag = document.getElementById(id);
			let text = wordTag.textContent;

			console.log("Calling recognition ...");
			// let count = 0;
			// let inputText = null;
			// let waitTime = ((text.length < 3 ? 3 : text.length) / 3) * 1000; // 3 characters per second
			recognizeSpeech(text);
			// let intervalId = setInterval(function () {
			// 	if (recognizedText != null) {
			// 		console.log("Calling getPinyin...");
			// 		inputText = recognizedText;
			// 		getPinyin(text, inputText);
			// 		clearInterval(intervalId);
			// 		recognizedText = null;
			// 		count = 0;
			// 	}
			// 	if (count > 2) {
			// 		console.log("Recognization failed for", text);
			// 		clearInterval(intervalId);
			// 		recognizedText = null;
			// 		count = 0;
			// 		// TODO error handling
			// 		// call checkPinyin() to show error message
			// 	}
			// 	count++;
			// }, waitTime);
		}

		/**
		 * Checks if the pinyins of two texts are same.
		 * Exactly same or there are some wrong tones.
		 */
		function checkPinyin(pinyin) {
			// TODO improve the comparison method
			// check tones
			let img = null;
			let textPinyin = removePuntuciation(pinyin.textPinyin);
			let inputTextPinyin = removePuntuciation(pinyin.inputTextPinyin);
			if (textPinyin.localeCompare(inputTextPinyin, undefined, { sensitivity: 'accent' }) === 0) {
				img = document.getElementById('great');
				img.style.display = 'block';
			} else {
				img = document.getElementById('try-again');
				img.style.display = 'block';
			}
			document.getElementById('recognization').style.display = 'block'
			document.getElementById('input-text').textContent = pinyin.inputText;
			document.getElementById('input-pinyin').textContent = pinyin.inputTextPinyin;
		}

		/**
		 * Removes all the puntuciation marks (English, Chinese and spaces)
		 */
		function removePuntuciation(text) {
			let chars = text.trim();
			let starter = chars.substring(0, 3);
			if (starter.localeCompare('Hƒìi', undefined, { sensitivity: 'base' }) === 0) {
				chars = chars.substring(3);
			}
			chars = chars.replace(/[ .,\/#!$%\^&\*;:{}=\-_`~()?"'<>[\]\\]/g, "");
			chars = chars.replace(/[Ôºå„ÄÇÔºõÔºöÔºü‚Äò‚Äô‚Äú‚ÄùÔºÅ„Äê„Äë]/g, "");
			return chars;
		}

		/**
		 * Turns on the microphone and the results of the pronunciation.
		 */
		function clearSpeechSection() {
			let tag = document.getElementById('speech-check');
			tag.style.display = 'none';
			tag = document.getElementById('try-again');
			tag.style.display = 'none';
			tag = document.getElementById('great');
			tag.style.display = 'none';
			tag = document.getElementById('recognization');
			tag.style.display = 'none';
		}

		/** 
		 * Gets speech from microphone and recognizes it to a text. 
		 */
		async function recognizeSpeech(text) {
			// 2.5 characters per second, 1 second minumum
			let waitTime = ((text.length < 3 ? 4 : text.length) / 2.5) * 1000;
			try {
				// Get microphone access
				let stream = await navigator.mediaDevices.getUserMedia({ audio: true });

				// Create MediaRecorder to capture audio
				let mediaRecorder = new MediaRecorder(stream);
				let audioChunks = [];

				mediaRecorder.ondataavailable = (event) => {
					audioChunks.push(event.data);
				};

				mediaRecorder.onstop = async () => {
					// Convert audio to Base64
					let audioBlob = new Blob(audioChunks, { type: 'audio/ogg; codecs=opus' });
					let base64Audio = await convertBlobToBase64(audioBlob);

					// Send audio to Google Speech-to-Text API
					transcribeAudio(text, base64Audio);
				};

				// Start recording
				mediaRecorder.start();
				console.log("Recording started...");

				// Stop recording after waitTime seconds (adjust as needed)
				setTimeout(() => {
					mediaRecorder.stop();
					console.log("Recording stopped.");
				}, waitTime);
			} catch (error) {
				console.error("Error accessing microphone:", error);
			}
		}

		/**
		 * Converts Blob (audio file) to Base64
		 */
		function convertBlobToBase64(blob) {
			return new Promise((resolve) => {
				let reader = new FileReader();
				reader.onloadend = () => resolve(reader.result.split(',')[1]); // Extract Base64
				reader.readAsDataURL(blob);
			});
		}

		/**
		 * Sends Base64 audio to Google Speech-to-Text API
		 */
		async function transcribeAudio(text, base64Audio) {
			// console.log("Base64 Audio (First 100 chars):", base64Audio.substring(0, 100));
			let requestBody = {
				config: {
					"encoding": "WEBM_OPUS",
					"sampleRateHertz": 48000,
					languageCode: "zh-CN",
					speechContexts: [
						{
							phrases: ["Èõ∂", "‰∏Ä", "‰∫å", "‰∏â", "Âõõ", "‰∫î", "ÂÖ≠", "‰∏É", "ÂÖ´", "‰πù", "ÂçÅ"],
							boost: 20.0
						}
					]
				},
				audio: {
					content: base64Audio,
				},
			};

			try {
				let response = await fetch(STT_URL, {
					method: "POST",
					headers: { "Content-Type": "application/json" },
					body: JSON.stringify(requestBody),
				})
				// .then(response => response.json())
				// // .then(data => console.log("API Response:", data))
				// .catch(error => console.error("Fetch Error:", error));

				if (!response.ok) {
					// Get raw response for debugging
					let errorText = await response.text();
					console.error("Error response:", errorText);
					throw new Error(`HTTP error! Status: ${response.status}`);
				}

				let data = await response.json();
				console.log("Speech to text result:", data);

				if (data.results) {
					let inputText = data.results.map(result => result.alternatives[0].transcript).join(" ");
					console.log("Recognized Speech: " + inputText);
					getPinyin(text, inputText);
				} else {
					console.error("No speech detected!");
				}
			} catch (error) {
				console.error("Error transcribing audio:", error);
			}
		}

		/** 
		 * Gets pinyins for comparing 
		 */
		async function getPinyin(text, inputText) {
			let encodedText = encodeURIComponent(text);
			let encodedInputText = encodeURIComponent(inputText);
			let urlText = TRANSLATOR_URL + encodedText;
			let urlInputText = TRANSLATOR_URL + encodedInputText;

			let response = await fetch(urlText);
			let data = await response.json();
			let textPinyin = data[0].map(sentence => sentence[3]).join(" ");

			response = await fetch(urlInputText);
			data = await response.json();
			let inputTextPinyin = data[0].map(sentence => sentence[3]).join(" ");
			console.log("pinyinText, pinyinInputText:[" + textPinyin + '], [' + inputTextPinyin + ']');

			let pinyin = {
				'text': text,
				'textPinyin': textPinyin.trim(),
				'inputText': inputText,
				'inputTextPinyin': inputTextPinyin.trim(),
			}
			checkPinyin(pinyin);
		}

		// Add event listeners for mouseup and keyup to detect text selection
		if (!isMobile()) {
			document.addEventListener('mouseup', sayHighlighted);
			document.addEventListener('keyup', sayHighlighted);
		}

	</script>
	<style>
		.chinese {
			font-family: KaiTi;
			font-size: 32px;
			font-weight: bold;
			color: darkgreen;
		}

		.english {
			font-family: 'Times New Roman', Times, serif;
			font-size: 32px;
			font-weight: bold;
			color: darkgreen;
			cursor: pointer;
		}

		.item-name {
			font-family: 'Times New Roman', Times, serif;
			font-size: 20px;
			color: brown;
		}

		.pinyin {
			font-family: 'Times New Roman', Times, serif;
			font-size: 20px;
			color: darkgreen;
		}

		.phrase {
			font-family: KaiTi;
			font-size: 20px;
			color: darkgreen;
		}

		.sentence {
			font-family: KaiTi;
			font-size: 20px;
			color: darkgreen;
		}

		.symbol {
			font-family: 'Times New Roman', Times, serif;
			font-size: 20px;
			margin-left: 20px;
			color: darkgreen;
			cursor: pointer;
		}

		.big-symbol {
			font-family: 'Times New Roman', Times, serif;
			font-size: 36px;
			cursor: pointer;
		}

		.recording {
			height: 50px;
			cursor: pointer;
		}

		.picture {
			width: 100%;
			cursor: pointer;
		}

		.picture-default {
			margin-top: 25%;
			margin-left: 20%;
			width: 50%;
			cursor: pointer;
		}

		.no-show {
			display: none;
		}

		.center-item {
			display: flex;
			align-items: center;
			justify-content: center;
		}

		.high-item {
			min-height: 180px;
			cursor: pointer;
		}

		.category {
			position: fixed;
			bottom: 10px;
			width: 1000px;
			margin-left: -60px;
			padding: 6px 0px 6px 4px;
			background-color: antiquewhite;
		}

		.clickable {
			font-family: SimSun;
			font-size: 15px;
			color: rgb(77, 77, 77);
		}

		.clickable:hover {
			color: brown;
			text-decoration: underline;
			font-weight: bold;
			cursor: pointer;
		}
	</style>
</head>

<body>
	<!-- The word pannel (chinese, english, picture, and symbols)-->
	<div id='character-row' class='row'>
		<!-- The left card that is for the Chinese character and English word -->
		<div class='col-sm-6'>
			<div class="card border-0">
				<div class="card-body">
					<div class='row'>
						<div class='col-sm-12 high-item'>
							<span id='character' onclick="showPicture()"
								title="click the question mark to show/hide the picture"></span>
						</div>
					</div>
					<div class='row'>
						<div class='col-sm-12 center-item'>
							<span id='chinese' class="chinese"></span>
							<span class="symbol" title="Mandarin" onclick="say('zh-CN', 'chinese')">üó£Ô∏è</span>
							<span class="symbol" title="Cantonese" onclick="say('yue-HK', 'chinese')">üîà</span>
							<span class="symbol" title="Talk Mandarin"
								onclick="speechCheck('zh-CN', 'chinese')">üé§</span>
						</div>
					</div>
					<div class='row'>
						<div class='col-sm-12 center-item'>
							<span id='english' class='english'></span>
							<span class="symbol" title="English" onclick="say('en-US', 'english')">üîä</span>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- The right card that is a picture and the source of the picture is assigned dynamicallly -->
		<div class='col-sm-6'>
			<div id='picture-card' class="card-body">
				<div class='row'>
					<div class='col-sm-12 mt-4'>
						<img id="picture-default" src="" class="picture-default no-show" onclick="showPicture()" />
						<img id="picture" src="" class="picture no-show" onclick="showPicture()" />
					</div>
				</div>
			</div>
		</div>
	</div>

	<!-- The bottom item that is for pinyin, phrases and sentence -->
	<div id='word-card'>
		<div class='row'>
			<div class='col-sm-2'>
				<p class="item-name">Pinyin</p>
			</div>
			<div class='col-sm-4'>
				<p class="item-name">Phrase
					<span class="symbol" title="Mandarin" onclick="say('zh-CN', 'phrase')">üó£Ô∏è</span>
					<span class="symbol" title="Cantonese" onclick="say('yue-HK', 'phrase')">üîà</span>
					<span class="symbol" title="Talk Mandarin" onclick="speechCheck('zh-CN', 'phrase')">üé§</span>
				</p>
			</div>
			<div class='col-sm-6'>
				<p class="item-name">Sentence
					<span class="symbol" title="Mandarin" onclick="say('zh-CN', 'sentence')">üó£Ô∏è</span>
					<span class="symbol" title="Cantonese" onclick="say('yue-HK', 'sentence')">üîà</span>
					<span class="symbol" title="Talk Mandarin" onclick="speechCheck('zh-CN', 'sentence')">üé§</span>
				</p>
			</div>
		</div>

		<div class='row'>
			<div class='col-sm-2'>
				<p id='pinyin' class="pinyin"></p>
			</div>
			<div class='col-sm-4'>
				<p id="phrase" class="phrase"></p>
			</div>
			<div class='col-sm-6'>
				<p id="sentence" class="sentence"></p>
			</div>
		</div>
	</div>

	<!-- This card is for getting voice and check pronunciation -->
	<div id='speech-check' class="no-show">
		<div class='row'>
			<div class='col-sm-5 phrase'>ËØ∑ËØ¥ËØùÔºö
				<img title='recording' class="recording" onclick="clearSpeechSection()"
					src=" https://lh3.googleusercontent.com/pw/AP1GczO7ifuRk-YKXYpHr4u2fn2MIJzxc_914kbWqiSmSiXwO6c9ij5MtHgb6_Un7uCFhGet-E4BP3GtofKcQbsvOTulJQjHZ52sFLMOR-aR62Qpo5QpgBVkhgjmN2c_HZ6mZK5JHxUfbDNW7YBbLEV-LOk3ww=w1008-h313-s-no-gm?authuser=0" />
			</div>
			<div class='col-sm-7'>
				<img id='try-again' class='no-show' title='try again' height='70px'
					src="https://lh3.googleusercontent.com/pw/AP1GczNsDHMBuamZwHaawHrSswRIT2SN9g8QFaRtYTqDwYmp1KlN37makoEXMe92B9NcoMIIaq5sysqFf4N3Ii_gwtr7hpW3DM5mqD6LMxQYpjCQ7y8exwVrPtE23TpbYDcV2GVs4ZI6IqX7zMejdGkbJSpPrQ=w564-h290-s-no-gm?authuser=0" />
				<img id='great' class='no-show' title='great' height='70px'
					src="https://lh3.googleusercontent.com/pw/AP1GczNipNqOFp3kEQQaUZ5CV2Sa4J8OoMR3nQw3O410tJu-BfZUIAUZy9RK8Io--YkyM4tqxVMzw26XsbSU44lfC-2LZw2Cfy9afxnWFcdG-mX8MbJXYdrrS5GlpnTz8CC3rOL0k-NPpdxt42j5ZPIh6sS-Dw=w783-h492-s-no-gm?authuser=0" />
			</div>
		</div>
		<div id='recognization' class='row no-show'>
			<div class='col-sm-12'>
				<p>
					<span class="sentence">‰Ω†ÂàöËØ¥ÁöÑÊòØÔºö</span>
					<span id="input-text" class="sentence"></span> „Äê
					<span id="input-pinyin" class="pinyin"></span>„Äë
				</p>
			</div>
		</div>
	</div>

	<!-- For generating some image dynamically -->
	<canvas id="textCanvas" class="card-body no-show"></canvas>

	<script>
		updatePage('1');
		buildCategories();
	</script>

</body>

</html>